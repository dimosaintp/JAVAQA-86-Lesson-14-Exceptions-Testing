package ru.netology.repository;
import ru.netology.domain.PurchaseItem;


// Урок 3. Менеджер Mockito.

// 1. Менеджер получает репозиторий через конструктор, а не создаёт его внутри себя, то есть можно при тестировании
// подставить туда нужную реализацию.
// 2. Менеджер не должен (и ему не нужно) ничего знать о реализации.
// 3. Используется разделение ответственности между бизнес-логикой и хранением данных.
// Разделение ответственности важно: мы позволяем заменять некоторые компоненты системы, не переписывая
// всю систему целиком.
// Например, если мы поменяем внутреннюю реализацию ProductRepository, то сам ProductManager не изменится,
// так как он опирается на внешний интерфейс и поведение репозитория.
// Под интерфейсом мы здесь понимаем набор публичных методов.

// Действия.
// 1. Заводим ячейку repo
// 2. Принимать ячейку repo будем через конструктор ProductManager.
// 3. Добавляем метод добавления элемента в корзину.
// 4. Метод getItems реализующий ответ на запрос показа всех элементов в корзине.
// 5. Получаем от репозитория массив all всех элементов в корзине.

// 6. Так как в репозитории элементы расположены в том порядке в котором они добавлялись, а нам нужно вернуть
// в обратном порядке, чтобы последний добавленный элемент был в начале.
// Для этого создадим ещё один массив reversed.
// 6.1. Проходим циклом по индексам массива reversed. На данном этапе там лежат только null.
// Вопрос. Если мы хотим заполнить новую ячейку в массиве reversed,
// то из какой ячейки надо копировать из старого массива?
// Для ячейки 0 нам нужна самая последняя ячейка, которая будет: all.length - 1.
// Для ячейки 1 нам нужна ячейка: all.length - 1 - 1.
// Для ячейки 2 нам нужна ячейка: all.length - 1 - 2.

// reversed[i] = all[all.length - 1 - i];
// для ячейки 0 это будет: последняя ячейка.
// для ячейки 1 это будет: предпоследняя ячейка.
// в итоге возвращаем этот массив: return reversed;

// 7. Добавляем метод подсчёта общей суммы покупки.
// Для каждой позиции в корзине мы берём кол-во продукта, его цену за 1 шт. и умножаем их.
// Получаем стоимость одной позиции.
// Стоимость всех позиций суммируем в переменную sum.
// Возвращаем sum.

public class ProductManager {
    private ProductRepository repo; // Заводим ячейку.


    public ProductManager(ProductRepository repo) {
        this.repo = repo;
    }

    public void add(PurchaseItem item) {
        repo.save(item); // Ответ: сохраняет элемент в репозиторий.
    }

    public PurchaseItem[] getItems() {
        PurchaseItem[] all = repo.getItems();
        PurchaseItem[] reversed = new PurchaseItem[all.length];
        for (int i = 0; i < all.length; i++) {
            reversed[i] = all[all.length - 1 - i];
        }
        return reversed;
    }

    public int getTotal() {
        int sum = 0;
        for (PurchaseItem item : getItems()) {
            sum = sum + item.getCount() * item.getProductPrice();
        }
        return sum;
    }
}