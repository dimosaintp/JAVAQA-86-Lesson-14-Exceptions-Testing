package ru.netology.repository;

import ru.netology.domain.PurchaseItem;

// Урок 2. Репозиторий. Класс для хранения объектов.
// Корзина покупок.
// В корзину можно добавлять покупки, удалять, изменять количество определённого товара.
// При получении списка покупок последний добавленный элемент должен быть первым в списке.

// Состояние.
// В большинстве случаев для любой системы, содержащей набор элементов, можно выделить 3 ключевых состояния:
// 1. Элементов внутри системы не содержится.
// 2. Внутри системы есть ровно 1 элемент.
// 3. Внутри системы есть несколько элементов (больше одного).

public class ProductRepository {

    // Чтобы показать запомненные покупки, мы должны их сохранить.
    // Сохраним в массив.
    // Изначально пустой репозиторий ничего не помнит, поэтому массив длиною 0.
    // Добавление реализуем через создание нового массива в методе save.
    // Новый массив tmp выглядит как старый items, но содержит добавленную покупку.
    // В массиве tmp, который копирует массив items, мы задаём длину: длина массива items + 1, так как
    // мы будем использовать его не 1 раз, а множество раз.
    // Циклом мы проходим по массиву tmp от нуля до длины + 1.
    // Копируем в массив tmp содержимое items.
    // Копируем в tmp последнюю покупку. В параметре item содержится элемент, который нас просят добавить.

    private PurchaseItem[] items = new PurchaseItem[0];

    // Метод принимающий новую покупку для добавления.

    public void save(PurchaseItem item) {
        PurchaseItem[] tmp = new PurchaseItem[items.length + 1];
        for (int i = 0; i < items.length; i++) {
            tmp[i] = items[i];
        }
        tmp[tmp.length - 1] = item;
        items = tmp; // Присваиваем в поле items новый массив.
    }

    // Метод удаления покупки по её уникальному номеру.
    // Создаём новый массив, который отличается от items на одну покупку меньше.
    // Создаём переменную для сохранения места куда нам нужно будет скопировать в новый массив.
    // В цикле проходим по массиву items от нуля до длины - 1.
    // Если у item id не то, какое мы хотим удалить (item.getId() не равен id), то копируем в tmp содержимое items.
    // Иначе перед нами элемент, который мы хотим удалить и мы его не копируем.
    // Копируем в новый массив tmp содержимое items.

    /* 14.1 Стектрейс. Перехват ошибок.

    public void removeById(int id) {
        if (id < 0) {

            // Создаем отчёт об ошибке.
            RuntimeException error = new RuntimeException(
                    "Возникла ошибка: " + "id не может быть отрицательным числом."
            );
            // Вызываем исключение, начинаем процесс умирания программы.
            throw error;
        }

     */

    /* 14.2 Иерархия и выброс исключений

        // throws Exception - говорит о том, что здесь может возникнуть такое исключение.
        public void removeById(int id) throws Exception {
        if (id < 0) {
            throw new Exception(
                    "Возникла ошибка: " + "id не может быть отрицательным числом."
            );
        }

     */

    /* 14.2 Иерархия и выброс исключений */
    // throws Exception здесь мы убираем, так как наш метод не выкидывает ошибок вида Exception.

    public void removeById(int id) {
        if (id < 0) {
            throw new NegativeIdException(
                    "Возникла ошибка: " + "id не может быть отрицательным числом."
            );
        }

        PurchaseItem[] tmp = new PurchaseItem[items.length - 1];
        int copyToIndex = 0;
        for (PurchaseItem item : items) {
            if (item.getId() != id) {
                tmp[copyToIndex] = item;
                copyToIndex++;
            }
        }
        items = tmp;
    }

    // Метод, который возвращает все запомненные элементы в виде массива.
    // Мы делаем наш объект items так, что он уже запоминает всё в массив, поэтому мы просто отдаём items.

    public PurchaseItem[] getItems() {
        return items;
    }
}